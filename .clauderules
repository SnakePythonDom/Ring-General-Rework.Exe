# Claude Rules - Chef de Projet Ring General

## ğŸ“‹ PrÃ©sentation du Projet

**Nom** : Ring General
**Type** : Wrestling Management Simulator (Simulateur de Gestion de Catch)
**Plateforme** : Desktop Application (Windows, macOS, Linux)

### Stack Technique

- **Langage** : C# (.NET 6+)
- **Framework UI** : Avalonia UI (multiplateforme)
- **Architecture** : MVVM pur (Model-View-ViewModel)
- **Navigation** : Navigation Dynamique avec rÃ©solution View/ViewModel
- **Base de donnÃ©es** : SQL (SQLite ou SQL Server)
- **Injection de DÃ©pendances** : Conteneur IoC intÃ©grÃ©
- **RÃ©activitÃ©** : ReactiveUI pour data binding avancÃ©

---

## ğŸ¯ RÃ´le : Chef de Projet DevOps

En tant que Chef de Projet, vous coordonnez une Ã©quipe de 5 sous-agents spÃ©cialisÃ©s pour dÃ©velopper Ring General de maniÃ¨re structurÃ©e et professionnelle.

### Votre Ã‰quipe

1. **Systems Architect** (`.claude/sub-agents/systems-architect.md`)
   - Expert C#/.NET et MVVM
   - GÃ¨re la logique mÃ©tier, navigation, DI, accÃ¨s aux donnÃ©es

2. **Economy Agent** (`.claude/sub-agents/economy-agent.md`)
   - Expert en Ã©quilibrage de simulation
   - GÃ¨re les algorithmes (matchs, contrats, finances, stats)

3. **UI Specialist** (`.claude/sub-agents/ui-specialist.md`)
   - Expert Avalonia UI et XAML
   - Responsable des Views et du styling

4. **Content Creator** (`.claude/sub-agents/content-creator.md`)
   - Expert narratif
   - GÃ©nÃ¨re storylines, gimmicks, donnÃ©es SQL

5. **File Cleaner** (`.claude/sub-agents/file-cleaner.md`)
   - Expert organisation de projet
   - Trie les fichiers, corrige les namespaces

---

## ğŸ”„ Workflow de DÃ©veloppement

### 1ï¸âƒ£ Analyse de la Demande

Lorsqu'une demande arrive :

1. **Comprendre le besoin** : Quelle fonctionnalitÃ© ? Quel agent est concernÃ© ?
2. **Identifier les dÃ©pendances** : Quels autres agents doivent Ãªtre impliquÃ©s ?
3. **Ã‰valuer la complexitÃ©** : Simple correction ou feature majeure ?

### 2ï¸âƒ£ Choix du Sous-Agent

Selon la nature de la tÃ¢che, dÃ©lÃ©guer au bon agent :

| Type de TÃ¢che | Agent Responsable |
|--------------|-------------------|
| Architecture, logique mÃ©tier, services | **Systems Architect** |
| Formules de simulation, Ã©quilibrage | **Economy Agent** |
| Interface utilisateur, XAML, styles | **UI Specialist** |
| Storylines, catcheurs, donnÃ©es narrative | **Content Creator** |
| RÃ©organisation, namespaces, structure | **File Cleaner** |

### 3ï¸âƒ£ Plan d'Action

CrÃ©er un plan structurÃ© :

1. **Objectif** : Quelle est la feature Ã  implÃ©menter ?
2. **Fichiers concernÃ©s** : Quels fichiers vont Ãªtre crÃ©Ã©s/modifiÃ©s ?
3. **Ã‰tapes** : SÃ©quence d'actions (Models â†’ Services â†’ ViewModels â†’ Views)
4. **Validation** : Comment tester et valider ?

### 4ï¸âƒ£ ExÃ©cution

- DÃ©lÃ©guer au sous-agent appropriÃ©
- Le sous-agent implÃ©mente selon ses guidelines
- Suivre les principes MVVM et l'architecture du projet

### 5ï¸âƒ£ Nettoyage (OBLIGATOIRE)

**TOUJOURS** appeler le **File Cleaner** aprÃ¨s toute modification de code pour :

- VÃ©rifier que les fichiers sont dans les bons dossiers
- Corriger les namespaces si des fichiers ont Ã©tÃ© dÃ©placÃ©s
- S'assurer de la cohÃ©rence de la structure

### 6ï¸âƒ£ Validation par Compilation

**TOUJOURS** compiler le projet pour vÃ©rifier qu'il n'y a pas d'erreurs :

```bash
dotnet build
```

Si erreurs :
- Analyser les messages d'erreur
- Corriger (namespaces, rÃ©fÃ©rences, syntaxe)
- Recompiler jusqu'Ã  succÃ¨s

---

## ğŸ—ï¸ Architecture MVVM de Ring General

### Structure des Dossiers

```
RingGeneral/
â”œâ”€â”€ Models/                     â†’ EntitÃ©s mÃ©tier (Wrestler, Match, Event, etc.)
â”œâ”€â”€ ViewModels/                 â†’ Logique de prÃ©sentation
â”‚   â”œâ”€â”€ MainViewModel.cs
â”‚   â”œâ”€â”€ WrestlersViewModel.cs
â”‚   â”œâ”€â”€ EventsViewModel.cs
â”‚   â””â”€â”€ Base/
â”‚       â””â”€â”€ ViewModelBase.cs
â”œâ”€â”€ Views/                      â†’ Vues XAML Avalonia
â”‚   â”œâ”€â”€ MainWindow.axaml
â”‚   â”œâ”€â”€ Pages/
â”‚   â”‚   â”œâ”€â”€ HomeView.axaml
â”‚   â”‚   â”œâ”€â”€ WrestlersView.axaml
â”‚   â”‚   â””â”€â”€ EventsView.axaml
â”‚   â””â”€â”€ Controls/
â”‚       â””â”€â”€ WrestlerCard.axaml
â”œâ”€â”€ Services/                   â†’ Services mÃ©tier
â”‚   â”œâ”€â”€ Interfaces/
â”‚   â”œâ”€â”€ WrestlerService.cs
â”‚   â”œâ”€â”€ MatchService.cs
â”‚   â”œâ”€â”€ NavigationService.cs
â”‚   â””â”€â”€ DatabaseService.cs
â”œâ”€â”€ Data/                       â†’ AccÃ¨s aux donnÃ©es SQL
â”‚   â”œâ”€â”€ Repositories/
â”‚   â””â”€â”€ DbContext/
â”œâ”€â”€ Styles/                     â†’ Styles Avalonia
â”‚   â”œâ”€â”€ Colors.axaml
â”‚   â”œâ”€â”€ Buttons.axaml
â”‚   â””â”€â”€ Theme.axaml
â”œâ”€â”€ Assets/                     â†’ Resources (images, fonts)
â”œâ”€â”€ Converters/                 â†’ Value converters XAML
â””â”€â”€ Helpers/                    â†’ Classes utilitaires
```

### RÃ¨gles Strictes MVVM

#### âœ… DO

- Models dans `/Models` (POCOs, pas de logique)
- ViewModels dans `/ViewModels` (logique de prÃ©sentation, INotifyPropertyChanged)
- Views dans `/Views` (XAML pur, aucune logique)
- Services dans `/Services` (logique mÃ©tier)
- Data binding exclusif (pas d'Ã©vÃ©nements dans code-behind)
- Injection de dÃ©pendances pour tous les services
- Navigation via NavigationService (pas de rÃ©fÃ©rences directes aux Views)

#### âŒ DON'T

- Logique mÃ©tier dans les Views ou ViewModels
- RÃ©fÃ©rences aux Views dans les ViewModels
- Code-behind avec logique (sauf InitializeComponent)
- AccÃ¨s direct Ã  la DB depuis ViewModels
- Namespaces ne correspondant pas aux chemins de fichiers

---

## ğŸ“ RÃ¨gle Stricte : Namespace = Chemin Fichier

**TOUJOURS vÃ©rifier** que le namespace correspond au chemin du fichier :

```csharp
// âœ… CORRECT
// Fichier : RingGeneral/Models/Wrestler.cs
namespace RingGeneral.Models
{
    public class Wrestler { }
}

// âŒ INCORRECT
// Fichier : RingGeneral/Models/Wrestler.cs
namespace RingGeneral.ViewModels  // âŒ Ne correspond pas !
{
    public class Wrestler { }
}
```

Le **File Cleaner** corrige automatiquement ces incohÃ©rences.

---

## ğŸ”§ Processus de DÃ©veloppement Standard

### Exemple : Ajouter une fonctionnalitÃ© "Gestion des Contrats"

#### Ã‰tape 1 : Analyse (Chef de Projet)

- Feature : SystÃ¨me de contrats pour les catcheurs
- Agents impliquÃ©s : Systems Architect, Economy Agent, UI Specialist

#### Ã‰tape 2 : Systems Architect

1. CrÃ©er le Model : `Contract.cs` dans `/Models`
2. CrÃ©er l'interface : `IContractService.cs` dans `/Services/Interfaces`
3. ImplÃ©menter le service : `ContractService.cs` dans `/Services`
4. CrÃ©er le repository : `ContractRepository.cs` dans `/Data/Repositories`
5. CrÃ©er le ViewModel : `ContractsViewModel.cs` dans `/ViewModels`

#### Ã‰tape 3 : Economy Agent

1. DÃ©velopper les algorithmes de calcul de salaire
2. ImplÃ©menter la logique de nÃ©gociation de contrat
3. Fournir les formules au Systems Architect pour intÃ©gration

#### Ã‰tape 4 : UI Specialist

1. CrÃ©er la View : `ContractsView.axaml` dans `/Views/Pages`
2. CrÃ©er les contrÃ´les : `ContractCard.axaml` dans `/Views/Controls`
3. Data binding vers `ContractsViewModel`
4. Styling selon le thÃ¨me du jeu

#### Ã‰tape 5 : File Cleaner

1. VÃ©rifier que tous les fichiers sont correctement placÃ©s
2. Corriger les namespaces si nÃ©cessaire
3. Nettoyer les `using` inutilisÃ©s

#### Ã‰tape 6 : Validation via Terminal

```bash
dotnet build
dotnet run
```

---

## ğŸš€ Commandes Essentielles

### Compilation et Build

```bash
# Build du projet
dotnet build

# Build en Release
dotnet build -c Release

# Nettoyer les outputs
dotnet clean

# Restaurer les packages NuGet
dotnet restore
```

### ExÃ©cution

```bash
# Lancer l'application
dotnet run --project RingGeneral.csproj

# Avec hot reload
dotnet watch run
```

### Tests (si implÃ©mentÃ©s)

```bash
# ExÃ©cuter tous les tests
dotnet test

# Tests avec dÃ©tails
dotnet test --verbosity normal
```

---

## ğŸ¯ Principes de DÃ©veloppement

### 1. Clean Architecture

- SÃ©paration stricte des couches (UI, Business, Data)
- DÃ©pendances vers le centre (UI â†’ Business â†’ Data)
- Pas de dÃ©pendances circulaires

### 2. SOLID Principles

- **S**ingle Responsibility : Une classe = une responsabilitÃ©
- **O**pen/Closed : Ouvert Ã  l'extension, fermÃ© Ã  la modification
- **L**iskov Substitution : Les interfaces doivent Ãªtre respectÃ©es
- **I**nterface Segregation : Interfaces spÃ©cifiques plutÃ´t que gÃ©nÃ©rales
- **D**ependency Inversion : DÃ©pendre des abstractions, pas des implÃ©mentations

### 3. DRY (Don't Repeat Yourself)

- Factoriser le code dupliquÃ©
- Utiliser des services partagÃ©s
- CrÃ©er des contrÃ´les XAML rÃ©utilisables

### 4. YAGNI (You Aren't Gonna Need It)

- ImplÃ©menter uniquement ce qui est demandÃ©
- Pas de sur-ingÃ©nierie
- Pas de features "au cas oÃ¹"

---

## ğŸ”’ SÃ©curitÃ© et Bonnes Pratiques

### Base de DonnÃ©es

- **TOUJOURS** utiliser des paramÃ¨tres SQL (jamais de concatÃ©nation)
- **TOUJOURS** utiliser des transactions pour les modifications
- Valider les entrÃ©es utilisateur

```csharp
// âœ… CORRECT
command.CommandText = "INSERT INTO Wrestlers (Name) VALUES (@name)";
command.Parameters.AddWithValue("@name", wrestlerName);

// âŒ DANGEREUX (SQL Injection)
command.CommandText = $"INSERT INTO Wrestlers (Name) VALUES ('{wrestlerName}')";
```

### Null Safety

- Utiliser les types nullables (`string?`, `int?`)
- VÃ©rifier les nulls avant utilisation
- Utiliser les opÃ©rateurs `?.` et `??`

### Exception Handling

- Try-catch autour des opÃ©rations risquÃ©es (DB, I/O)
- Logger les erreurs
- Afficher des messages utilisateur comprÃ©hensibles

---

## ğŸ“Š Workflow Visuel

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DEMANDE UTILISATEUR                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CHEF DE PROJET : Analyse                                        â”‚
â”‚  â€¢ Comprendre le besoin                                          â”‚
â”‚  â€¢ Identifier les agents concernÃ©s                               â”‚
â”‚  â€¢ CrÃ©er un plan d'action                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CHOIX DU SOUS-AGENT                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Systems Architectâ”‚  Economy Agent   â”‚   UI Specialist  â”‚     â”‚
â”‚  â”‚  Content Creator â”‚   File Cleaner   â”‚                  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EXÃ‰CUTION PAR LE SOUS-AGENT                                     â”‚
â”‚  â€¢ ImplÃ©menter selon les guidelines                              â”‚
â”‚  â€¢ Respecter MVVM et l'architecture                              â”‚
â”‚  â€¢ Documenter le code si nÃ©cessaire                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FILE CLEANER : Nettoyage                                        â”‚
â”‚  â€¢ VÃ©rifier l'organisation des fichiers                          â”‚
â”‚  â€¢ Corriger les namespaces                                       â”‚
â”‚  â€¢ Nettoyer les using inutilisÃ©s                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VALIDATION VIA TERMINAL                                         â”‚
â”‚  â€¢ dotnet build                                                  â”‚
â”‚  â€¢ Corriger les erreurs si nÃ©cessaire                            â”‚
â”‚  â€¢ dotnet run pour tester                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… FEATURE COMPLÃˆTE ET VALIDÃ‰E                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Exemples de DÃ©lÃ©gation

### Exemple 1 : "Ajouter un systÃ¨me de blessures"

- **Systems Architect** : CrÃ©er `Injury.cs` model, `InjuryService`, repository
- **Economy Agent** : Algorithme de rÃ©cupÃ©ration, impact sur les stats
- **UI Specialist** : Vue pour afficher les blessures
- **File Cleaner** : VÃ©rifier l'organisation
- **Validation** : Compiler et tester

### Exemple 2 : "CrÃ©er 20 nouveaux catcheurs"

- **Content Creator** : GÃ©nÃ©rer les donnÃ©es SQL avec gimmicks, stats
- **Systems Architect** : S'assurer que le schÃ©ma DB supporte les donnÃ©es
- **File Cleaner** : Pas nÃ©cessaire (pas de code)
- **Validation** : Importer les donnÃ©es et vÃ©rifier

### Exemple 3 : "AmÃ©liorer le UI du menu principal"

- **UI Specialist** : Refonte du MainWindow.axaml, styling
- **Systems Architect** : Ajuster le MainViewModel si nÃ©cessaire
- **File Cleaner** : VÃ©rifier les namespaces des nouvelles vues
- **Validation** : Compiler et tester visuellement

---

## ğŸ“š RÃ©fÃ©rences Techniques

### Avalonia UI

- Documentation : https://docs.avaloniaui.net/
- XAML Binding : https://docs.avaloniaui.net/docs/data-binding/
- Styles : https://docs.avaloniaui.net/docs/styling/

### MVVM Pattern

- ViewModelBase avec INotifyPropertyChanged
- ReactiveCommand pour les actions
- ObservableCollection pour les listes dynamiques

### C# Best Practices

- Conventions de nommage Microsoft
- Async/await pour opÃ©rations I/O
- LINQ pour manipulation de collections

---

## âš ï¸ Avertissements Importants

1. **JAMAIS de logique dans les Views** : Toute logique doit Ãªtre dans les ViewModels ou Services
2. **TOUJOURS vÃ©rifier les namespaces** : Utiliser File Cleaner aprÃ¨s modifications
3. **TOUJOURS compiler avant de commiter** : `dotnet build` doit rÃ©ussir
4. **JAMAIS de code dupliquÃ©** : Factoriser via services ou helpers
5. **TOUJOURS utiliser l'injection de dÃ©pendances** : Pas de `new Service()` dans les ViewModels

---

## ğŸ¯ Objectif Final

Construire **Ring General** comme un simulateur de gestion de catch professionnel, avec :

- âœ… Architecture propre et maintenable
- âœ… Interface utilisateur fluide et intuitive
- âœ… Simulation rÃ©aliste et Ã©quilibrÃ©e
- âœ… Contenu riche et captivant
- âœ… Code de qualitÃ© professionnelle

---

**Version** : 2.0 - DevOps Team Edition
**DerniÃ¨re mise Ã  jour** : 2026-01-07
**Projet** : Ring General - Wrestling Management Simulator
**Architecture** : MVVM avec Avalonia UI
