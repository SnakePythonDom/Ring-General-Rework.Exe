# Data Logic Standards - Ring General

## üóÑÔ∏è Standards Acc√®s aux Donn√©es

### SQL S√©curis√© - R√àGLE ABSOLUE
- **TOUJOURS** utiliser des param√®tres SQL
- **JAMAIS** de concat√©nation de cha√Ænes SQL
- **JAMAIS** de string interpolation dans les requ√™tes

### Exemples SQL Corrects
```csharp
// ‚úÖ CORRECT - Param√®tres nomm√©s
command.CommandText = "INSERT INTO Workers (Name, Popularite) VALUES (@name, @popularite)";
command.Parameters.AddWithValue("@name", workerName);
command.Parameters.AddWithValue("@popularite", popularite);

// ‚úÖ CORRECT - Param√®tres positionnels
command.CommandText = "SELECT * FROM Workers WHERE Popularite > ? AND Fatigue < ?";
command.Parameters.Add(populariteMin);
command.Parameters.Add(fatigueMax);
```

### Exemples SQL DANGEREUX (INTERDITS)
```csharp
// ‚ùå DANGEREUX - SQL Injection
command.CommandText = $"INSERT INTO Workers (Name) VALUES ('{workerName}')";

// ‚ùå DANGEREUX - Concat√©nation
command.CommandText = "SELECT * FROM Workers WHERE Name = '" + workerName + "'";
```

### Pattern Repository
- Un repository par domaine (23+ repositories sp√©cialis√©s)
- Interfaces dans `RingGeneral.Core/Interfaces/`
- Impl√©mentations dans `RingGeneral.Data/Repositories/`
- M√©thodes asynchrones pour toutes les op√©rations DB

### Transactions Obligatoires
```csharp
using var connection = _factory.CreateConnection();
using var transaction = connection.BeginTransaction();

try
{
    // Op√©rations multiples
    await ExecuteCommand1Async(command1, connection);
    await ExecuteCommand2Async(command2, connection);

    transaction.Commit();
}
catch
{
    transaction.Rollback();
    throw;
}
```

### Gestion des Connexions SQLite
- Utiliser `SqliteConnectionFactory` pour cr√©er les connexions
- **TOUJOURS** utiliser `using` pour les connexions et commandes
- Configurer correctement les pragmas SQLite si n√©cessaire

### Migrations Database
- Localisation : `/data/migrations/`
- Format : `001_description.sql`, `002_description.sql`
- **JAMAIS** modifier une migration existante
- Cr√©er une nouvelle migration pour chaque changement de sch√©ma

### Gestion d'Erreurs DB
```csharp
try
{
    // Op√©ration DB
}
catch (SqliteException ex) when (ex.SqliteErrorCode == 19) // Constraint violation
{
    Logger.Error("Violation de contrainte", ex);
    throw new DomainException("Donn√©es invalides", ex);
}
catch (SqliteException ex)
{
    Logger.Error("Erreur base de donn√©es", ex);
    throw new InfrastructureException("Erreur d'acc√®s aux donn√©es", ex);
}
```

### Validation des Donn√©es
- Valider les entr√©es avant insertion/modification
- Utiliser des contraintes DB quand possible
- G√©rer les valeurs null correctement avec les types nullable

### Optimisations SQLite
- Utiliser des indexes appropri√©s
- √âviter les requ√™tes N+1
- Utiliser les transactions pour les op√©rations batch
- Consid√©rer les pragmas de performance (WAL mode, etc.)

## üèóÔ∏è Architecture Repositories

### Structure Standard Repository
```csharp
public interface IWorkerRepository
{
    Task<IEnumerable<WorkerSnapshot>> GetAllAsync();
    Task<WorkerSnapshot?> GetByIdAsync(string workerId);
    Task SaveAsync(WorkerSnapshot worker);
    Task DeleteAsync(string workerId);
}

public class WorkerRepository : IWorkerRepository
{
    private readonly SqliteConnectionFactory _factory;

    public WorkerRepository(SqliteConnectionFactory factory)
    {
        _factory = factory;
    }

    // Impl√©mentations...
}
```

### Injection et Enregistrement
- Tous les repositories enregistr√©s comme Singleton dans `App.axaml.cs`
- Injection via constructeur obligatoire
- Utiliser `RepositoryFactory` pour la cr√©ation group√©e

## ‚ö†Ô∏è R√àGLES CRITIQUES

1. **PARAM√àTRES SQL** : Toujours, sans exception
2. **TRANSACTIONS** : Pour toute modification multiple
3. **ASYNC/AWAIT** : Toutes les m√©thodes DB
4. **USING STATEMENTS** : Pour toutes les ressources DB
5. **VALIDATION** : Entr√©es valid√©es avant DB
6. **LOGGING** : Toutes les erreurs DB logu√©es